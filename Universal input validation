// OBJECTIVE
// This function demands user input and validates it. 
// The aim is to make code within the body of our program
// as clean as possible.

// ARGUMENTS
// The first argument is the variable in which the input is
// to be stored. The second argument is a the name of a 
// lambda function of the form 
//        auto conditions = [](auto foo) { return foo != 0; };
// where foo != 0 is a sample statement.
// If there are not particular conditions that must be met,
// make the lambda function return true.

// USE
// Everytime user input is required, follow these steps:
// 1. Declare and initialize the variable. Initialization is required!
// 2. Declare an auto lambda function that returns true if conditions are met.
// 3. Provide UI with std::cout.
// 4. Call input_validation(variable, conditions).
// Observe that this way we can get and validate user input with at most 
// four lines of code. Remember to make the lambda return true if no conditions
// are specified.

// EXAMPLE
// double x = 0;
// auto x_validity = [](auto foo) { return foo != 0; };
// std::cout << "Enter input: ";
// input_validation(x, x_validity);

#include <iostream>
#include <limits>
template<class TYPE, class LAMBDA>
void input_validation(TYPE input, LAMBDA conditions) {
    while (1) { // Don't put std::cin as a condition.
        std::cin >> input; 
        if (std::cin.fail() || std::cin.get() != '\n') {
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            std::cout << "\n ERROR: Invalid input. Try again and press ENTER: ";
        }
        else if (!conditions(input)) {
            std::cout << "\n ERROR: Invalid input. Try again and press ENTER: ";
        }
        else break;
    }
}

// KNOWN BUGS
//    -- If the variable is unsigned and the user input is a minus sign with a few numbers,
//       std::cin stores the unsigned number entered.
